# Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程？

</br>

### chrome、Chromium、V8 三者的关系

-   V8 是一个由 Google 研发的开源 JavaScript 引擎

-   Chromium 是一个由 Google 主导开发的开源网页浏览器（基于 V8 引擎）

-   Chrome 是基于 Chromium 二次开发的浏览器

</br>
</br>

### 进程和线程

</br>

**什么是进程？**

启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程

</br>

**进程和线程之间的关系特点**

1. 线程是不能单独存在的，它是由进程来启动和管理的

2. 进程中的任意一线程执行出错，都会导致整个进程的崩溃

3. 线程之间共享进程中的数据

4. 当一个进程关闭之后，操作系统会回收进程所占用的内存

5. 进程之间的内容相互隔离，互不影响（可使用进程间通信（IPC）的机制进行通信）

</br>
</br>

### 单进程浏览器时代

单进程浏览器是指浏览器的所有功能模块（网络、插件、JavaScript 运行环境、渲染引擎和页面等）都是运行在同一个进程里

1. 不稳定：任意功能模块的崩溃都会导致浏览器的崩溃

2. 不流畅：同一时刻，只能运行一个模块，容易阻塞

3. 不安全：恶意插件、页面脚本的威胁

</br>
</br>

### 多进程浏览器时代

</br>

**架构**

1. 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能

2. 渲染进程（多个）：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 **JavaScript 引擎 V8 都是运行在该进程中**，默认情况下，**Chrome 会为每个网页（如果 A、B 两个网站协议和域名相同，会共用一个渲染进程）创建一个渲染进程**。出于安全考虑，**渲染进程都是运行在沙箱模式下**

3. GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程

4. 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程

5. 插件进程（多个）：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

</br>

**优点**

1. 进程之间相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程

2. 使用安全沙箱，即使在渲染进程或者插件进程里面执行了恶意程序，也无法突破沙箱去获取系统权限

</br>

**缺点**

1. 更高的资源占用：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源

2. 更复杂的体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了

</br>
</br>
</br>
</br>

# TCP 协议：如何保证页面文件能被完整送达浏览器？

</br>

### 一个数据包的“旅程”

互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输（例如：音频、视频）

</br>

**IP：负责把数据包送达目的主机**

访问任何网站时，实际上是通过电脑的 IP 地址信息把数据包发送给指定的电脑

</br>

**UDP：负责把数据包送达应用程序**

电脑收到数据包后，UDP 通过端口号把数据包分发给正确的程序。虽然 UDP 传输速度却非常快，但是不能保证数据可靠性：

1. 数据包在传输过程中容易丢失

2. 当大文件被拆分成很多小的数据包来传输时，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装还原这些数据包

</br>

**TCP：负责把数据完整地送达应用程序。**

TCP（Transmission Control Protocol，传输控制协议）是一种**面向连接的、可靠的、基于字节流**的传输层通信协议，相比于 UDP 协议，具有如下优势：

1. 对于数据包丢失的情况，TCP 提供重传机制

2. TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

一个完整的 TCP 连接的生命周期包括**建立连**、**传输数据**和**断开连接**三个阶段：

1. 建立连接（三次握手）：明确客户端和服务端的收、发能力是正常的

    - 第一次：客户端发包给服务端，服务端判断客户端是否具有发送包的能力

    - 第二次：服务端发包给客户端，客户端判断服务端端是否具有发送包、接受包的能力

    - 第三次：客户端再次发包给服务端，服务端判断客户端是否具有接受包的能力

2. 数据传输：接收端需要对每个数据包进行确认操作

    - 如果没有在规定时间内得到数据，就会触发重传机制

    - 如果在传输过程中会被拆分成很多小的数据包，接收端会按照 TCP 头中的序号为其排序

3. 断开连接（四次挥手）：服务端收到断开的信号时，应立即做出响应，避免客户端不知是否发送成功再多次发送断开的信号；此外，如果这时候某一方并不想断开连接的话，在第三次挥手的时候可以做出适当的调整

    - 第一次：客户端发送 ACK 确认断开连接的信号

    - 第二次：服务器收到后，立即响应一个 ACK 确认信号表示收到了信息

    - 第三次：服务器再次发送一个 FIN，告诉客户端已经成功断开

    - 第四次：客户端收到了 FIN，再次发送一个 ACK 告诉服务端已经收到关闭连接的消息

</br>
</br>
</br>
</br>
