# 浏览器的垃圾回收机制

</br>

### 前言

文章主要参考[《李兵老师-浏览器工作原理与实践》](https://time.geekbang.org/column/intro/216)课程，并对部分内容进行了合并和补充，再以自己的理解和归纳去进行总结

</br>
</br>

### 不同语言的垃圾回收策略

1. **手动回收**：何时分配内存、何时销毁内存都是由代码控制的，如果没有及时销毁内存，这种情况就被称为内存泄漏，例如：C 和 C++

2. **自动回收**：产生的垃圾数据是由垃圾回收器来释放的，例如：JavaScript、Java、Python

</br>
</br>

### JavaScript 中的栈空间和堆空间

1. 栈空间：原始类型（String、Boolean、Number、undefined、null、Symbol、BigInt）都是保存在栈空间中

2. 堆空间：引用类型（Function、Object）的地址值保存中栈空间中，具体数据内容保存在堆空间中

在函数调用过程中，JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率，因此需要引入堆空间来保存较大的数据。而**栈空间和堆空间的数据回收机制也是完全不同**

</br>
</br>

### 栈空间的数据回收

函数运行时，会创建一个执行上下文，**原始类型和引用类型的地址值都是保存在该执行上下文中的变量环境中**，当函数执行结束后，会摧毁该执行上下文，同时回收变量环境中的所有数据

</br>
</br>

### 堆空间的数据回收

堆空间的数据回收，就需要用到 JavaScript V8 引擎中的垃圾回收器

</br>

#### 新生代和老生代

在 V8 中会把堆分为新生代和老生代两个区域：

1. **新生代**：存放的是生存时间短的对象，新生区通常只支持 1 ～ 8M 的容量

2. **老生代**：存放的生存时间久的对象或者较大的对象，而老生区支持的容量就很大

</br>

#### V8 中的垃圾回收器

在 V8 中，有以下两种垃圾回收器：

1. 副垃圾回收器：主要负责新生代的垃圾回收

2. 主垃圾回收器：主要负责老生代的垃圾回收

</br>

#### 副垃圾回收器

1. 采用 **Scavenge 算法**，将新生代区域划分为两个区域，一个是对象区域，一个是空闲区域

2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作

    - 将对象区域中的垃圾做标记

    - 在垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中

    - 同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了**内存整理操作**

    - 整理完成之后，对象区域变成了空闲区域，空闲区域变成了对象区域，两者角色不停翻转操作

3. 采用了**对象晋升策略**，经过**两次**垃圾回收依然还存活的对象，会被移动到老生区中

</br>

#### 主垃圾回收器

1. 主垃圾回收器是采用**标记清除的算法**进行垃圾回收

    - **遍历整个调用栈，将使用到的对象标记为活动对象**

    - 清除掉垃圾数据

2. 在清除的过程中，会产生内存碎片，回收器又会使用**标记整理算法**整理内存

    - 让所有存活的对象都向一端移动，然后清除掉端边界的内存

</br>

#### 全停顿

1. 一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。

2. 如果堆中的数据有 1.5GB，那么 V8 实现一次完整的垃圾回收需要 1 秒以上的时间，也会造成 1 秒的页面卡顿。因此，V8 将标记的过程拆分为了一个一个的小任务（增量标记算法），与其他的 JavaScript 任务穿插执行

</br>
</br>
