# 为什么 CSS 动画比 JavaScript 高效？

</br>

### 显示器如何显示图像

1. 每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫**前缓冲区**的地方

2. 显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上

3. 显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换

</br>
</br>

### 帧 VS 帧率

显示更新时每一副图片称为一帧，如果 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）

</br>
</br>

### 如何生成一帧图像

1. 渲染进程将合成树进行分层

2. 分层后，生成每个图层的绘制指令，最后提交给合成线程去处理

3. 合成线程将图层进行分块，然后交给 GPU 进程去绘制位图

4. 位图绘制完成后，合成线程通知浏览器进程进行渲染

</br>
</br>

### 分层和合成机制

1. 如果没有采用分层机制，每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率

2. Chrome 在首次合成图块的时候使用一个低分辨率的图片进行展示，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容

</br>
</br>

### 如何利用分层技术优化代码

1. 使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换

2. 该属性会为你创建一个新的图层，动画更新的时候，直接由合成线程去处理，不会占用主线程

3. 但当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加

</br>
</br>

### 补充

1. 能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了

2. 能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容

3. 比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了

</br>
</br>
