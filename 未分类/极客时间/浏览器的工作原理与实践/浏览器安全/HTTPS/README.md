# HTTPS

</br>

### 在 HTTP 协议栈中引入安全层

HTTP 请求，在建立 TCP 连接之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。因此 HTTPS 就是在在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密

![image](./img/https.png)

安全层主要是职责是，对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作

</br>
</br>

### 第一版：使用对称加密

对称加密是指加密和解密都使用的是相同的密钥

![image](./img/https-1.png)

1. 浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法

2. 服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器

3. 浏览器和服务器分别返回确认消息

4. 浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的加密方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输

**问题**

虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，

</br>
</br>

### 第二版：使用非对称加密

1. 非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。

2. 在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为**公钥**，服务器自己留下的那个密钥称为**私钥**。顾名思义，**公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开**

![image](./img/https-2.png)

1. 首先浏览器还是发送加密套件列表给服务器

2. 服务器会选择一个加密套件，将加密套件和公钥一道发送给浏览器

3. 浏览器和服务器返回确认消息

4. 浏览器端向服务器端发送数据时，使用该公钥来加密数据，而黑客获取到了私钥也无法破解数据内容

**问题**

1. 非对称加密的效率太低

2. 无法保证服务器发送给浏览器的数据安全

</br>
</br>

### 第三版：对称加密和非对称加密搭配使用

在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输

![image](./img/https-3.png)

1. 浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random

2. 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥

3. 浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据

4. 服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息

服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。由于 pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了

**问题**

通过 DNS 劫持将 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了

</br>
</br>

### 第四版：添加数字证书

向权威机构称为 CA（Certificate Authority）申请数字证书（Digital Certificate)，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥

1. 浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random

2. 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和 **数字证书**

3. **浏览器验证数字证书**，验证通过后，浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据

4. 务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息

</br>
</br>

### 数字证书

1. 向 CA 机构提交公钥、公司、站点等信息并等待认证，信息审核通过，CA 会向极客时间签发认证的数字证书，同时包含一个 CA 生成的签名

2. CA 使用 Hash 函数来计算极客时间提交的明文信息，并得出信息摘要；然后 **CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极客时间的数字签名**（好比房产证上的盖章），可以通过数字签名来验证是否是该 CA 颁发的

3. 操作系统中会内置信任的顶级 CA 的证书信息，小型的 CA 机构又可以向顶级的 CA 机构申请成为中间 CA

</br>
</br>

### 补充

1. SSL 和 TLS 的关系：SSL 和 TLS 都是加密协议，SSL 是 TLS 的前身，1996 年推出 SSL3.0 版本，1999 年就基于 SSL3.0 发布了 TSL1.0 版本，2018 年发布了 TSL1.3 版本
