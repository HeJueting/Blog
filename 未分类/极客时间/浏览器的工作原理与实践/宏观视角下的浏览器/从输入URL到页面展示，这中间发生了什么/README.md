# 从输入 URL 到页面展示，这中间发生了什么？

</br>

### 1、用户输入

当用户在地址栏中输入一个查询关键字时，浏览器会判断输入的关键字是搜索内容，还是请求的 URL。

1. 如果搜索内容，浏览器会使用默认的搜索引擎，合成一个带搜索关键字的 URL

2. 如果搜索内容符合 URL 规则，那么浏览器会根据规则，加上 http 或 https 协议，合成为完整的 URL

在用户按下回车键之后，还会触发 JS 的 beforeunload 事件，询问用户是否离开当前页面

</br>
</br>

### 2、浏览器进程通过 IPC 机制把 URL 请求发送至网络进程

IPC 机制：多个进程间的通信机制

</br>
</br>

### 3、网络进程会判断该资源是否已经缓存

1. 浏览器第一次请求该资源时，服务器会在 HTTP 响应头中返回 Cache-Control 字段去告诉浏览器是否缓存该资源，通过 Max-age 参数可以设置缓存过期时长

2. 如果该资源命中缓存，会直接返回缓存中的资源给浏览器（code 200）

    - form memory cache：如果该资源加载过，且缓存在了内存当中，直接从内存中读取缓存（浏览器关闭后，数据将不存在）

    - from disk cache：从本地磁盘读取缓存

</br>
</br>

### 4、DNS 域名解析

如果这个 URL 不是一个标准的 IP 地址，还会进行 DNS 域名解析。如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用

1. 如果命中 DNS 缓存，直接从缓存中获取解析结果

2. 浏览器会请求 DNS 返回该域名对应的 IP，并进行缓存

如果该地址未标明端口号，http 协议默认为 80 端口，https 默认为 443 端口

</br>
</br>

### 5、如果是 HTTPS 协议，还需要先建立 TLS/SSL 连接

HTTPS = HTTP + ssl/tls 证书

</br>
</br>

### 6、等待 TCP 队列

Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成

</br>
</br>

### 7、建立 TCP 连接

1. 客户端 ——> 服务端，服务端校验客户端**是否具有发送包的能力**

2. 服务端 ——> 客户端，客户端校验服务端**是否具有发送包、接受包的能力**

3. 客户端 ——> 服务端，服务端校验客户端**是否具有接收包的能力**

</br>
</br>

### 8、发起 http 请求

TCP 连接建立之后，浏览器端会构建请求行、请求头、请求体等信息，然后向服务器发送构建的请求信息

1. 请求行：请求方法、请求 URI、HTTP 版本协议

2. 请求头：content-type、cookie、User-Agent、connection（keep-alive 重复使用 TCP 连接）

3. 请求体（body）

</br>
</br>

### 9、服务端 http 响应

服务器接收到 http 请求信息后，会根据请求信息生成响应数据

1. 响应行：HTTP 协议版本、状态码

2. 响应头：content-type、set-Cookie、Cache-Control、location

3. 响应体

</br>
</br>

### 10、断开 TCP 连接

四次挥手：服务端收到断开的信号时，应立即做出响应，避免客户端不知是否发送成功，然后再多次发送断开的信号；此外，如果这时候某一方并不想断开连接的话，在第三次挥手的时候可以做出适当的调整

1. 第一次：客户端发送 ACK 确认断开连接的信号

2. 第二次：服务器收到后，立即响应一个 ACK 确认信号表示收到了信息

3. 第三次：服务器再次发送一个 FIN，告诉客户端已经成功断开

4. 第四次：客户端收到了 FIN，再次发送一个 ACK 告诉服务端已经收到关闭连接的消息

</br>
</br>

### 11、浏览器解析响应信息

**重定向**

如果状态码是 301（临时重定向） 或者 302（永久重定向），浏览器会根据 location 字段进行重定向，又会发起新的 http 请求

**命中弱缓存**

如果状态码是 304，代表命中弱缓存，服务器告诉浏览器资源没有更新，直接使用缓存的资源

**响应 200**

正常响应成功的 code 为 200，然后浏览器会根据响应头中的 Content-Type 决定如何显示响应体的内容

1. html、css、javascript 等文件

2. 如果是 stream 类型，则会下载该文件

</br>
</br>

### 12、准备渲染进程

1. 如果解析的文件是 HTML 格式，浏览器就会准备一个新的渲染进程去渲染该内容。**相同域名和协议（不区分端口）的网页会共用一个渲染进程**

2. 准备好渲染进程之后，网络进程就会将该资源提交给渲染进程处理

3. 在提交的过程中，也会把地址栏的 URL、前进后退的历史状态同步给浏览器进程

</br>
</br>

### 13. 渲染处理

一旦资源提交给了渲染进程，他会把整个任务拆分为多个子任务，以**流水线**的形式进行处理（将上一个任务的处理结果返回给下一个任务，下一个任务继续处理）

</br>
</br>

### 14、构建 DOM 树

1. 浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构 —— DOM 树

2. 与 HTML 不同的是，**DOM 树是保存在内存中树状结构**，可以通过 JavaScript 来查询或修改其内容

</br>
</br>

### 15、解析 CSS

1. 渲染引擎接会收到 CSS 文本进行转换操作，转换为浏览器可以理解的结构 —— styleSheets（通过 document.styleSheets 可以查看）

2. 转换样式表中的属性值，使其标准化，才能被浏览器正确解析。例如：将 black 转为 rgb(0,0,0)

</br>
</br>

### 16、根据 DOM 树和 styleSheets，计算出每个节点的具体样式

计算规则：

1. 子元素继承父元素的 CSS 样式

2. 根据 CSS 的权重去计算

</br>
</br>

### 17、创建布局树，并计算元素位置

给 DOM 树添加样式后，因为 DOM 树还含有很多不可见的元素（display:none），因此还需要**创建一颗布局树**，并计算元素的位置

</br>
</br>

### 18、对布局树进行分层，并生成分层树

1. 这些图层，层叠加在一起构成了最终的页面图像

2. 拥有层叠上下文属性的元素会被提升为单独的一层

</br>
</br>

### 19、图层绘制

1. 为每个图层生成绘制列表，并将其提交到合成线程

2. 合成线程将图层分成图块，借助 GPU 进程加速生成位图，并保存在 GPU 内存中

3. 一旦所有位图都生成之后，合成线程就会通知浏览器进程，浏览器进程便将 GPU 内存中的内容进行显示
