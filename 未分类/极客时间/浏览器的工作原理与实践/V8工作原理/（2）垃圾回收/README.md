# 垃圾回收：垃圾数据是如何自动回收的？

</br>

### 不同语言的垃圾回收策略

1. 手动回收：何时分配内存、何时销毁内存都是由代码控制的，如果没有及时销毁内存，这种情况就被称为内存泄漏，例如：C 和 C++

2. 自动回收：产生的垃圾数据是由垃圾回收器来释放的，例如：JavaScript、Java、Python

</br>
</br>

### 调用栈（栈空间）中的数据回收

1. 函数运行时，在创建一个执行上下文的同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中该函数的执行上下文

2. 如果 ESP 指针移动，会从调用栈中弹出执行上下文，同时销毁该函数的执行上下文

3. 销毁的这个过程就会回收该执行上下文中的所有数据（这里的数据也可以理解为内存）

</br>
</br>

### 堆空间的数据回收

</br>

#### 代际假说和分代收集策略

代际假说有以下两个特点：

1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问

2. 不死的对象，会活得更久

</br>

#### 新生代和老生代

在 V8 中会把堆分为新生代和老生代两个区域：

1. 新生代中存放的是生存时间短的对象，新生区通常只支持 1 ～ 8M 的容量

2. 老生代中存放的生存时间久的对象或者较大的对象，而老生区支持的容量就很大

</br>

#### V8 中的垃圾回收器

要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器，在 V8 中，有以下两种垃圾回收器：

1. 副垃圾回收器，主要负责新生代的垃圾回收

2. 主垃圾回收器，主要负责老生代的垃圾回收

</br>

#### 垃圾回收器的工作流程

副垃圾回收器和主垃圾回收器都有类似的工作流程：

1. 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象

2. 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象

3. 内存整理（副垃圾回收器不会经历该步骤），数据清理后就会产生不连续的空间，简称为内存碎片

</br>

#### 副垃圾回收器

1. 采用 Scavenge 算法，将新生代区域划分为两个区域，一个是对象区域，一个是空闲区域

2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作

    - 对对象区域中的垃圾做标记

    - 在垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中

    - 同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作

    - 整理完成之后，对象区域变成了空闲区域，空闲区域变成了对象区域，两者角色不停翻转操作

3. 采用了**对象晋升策略**，经过两次垃圾回收依然还存活的对象，会被移动到老生区中

</br>

#### 主垃圾回收器

1. 主垃圾回收器是采用**标记清除的算法**进行垃圾回收

    - 遍历整个调用栈，将使用到的对象标记为活动对象

    - 清除掉垃圾数据

2. 在清除的过程中，会产生内存碎片，回收器又会使用**标记整理算法**整理内存

    - 让所有存活的对象都向一端移动，然后清除掉端边界的内存

</br>

#### 全停顿

1. 一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。

2. 如果堆中的数据有 1.5GB，那么 V8 实现一次完整的垃圾回收需要 1 秒以上的时间，也会造成 1 秒的页面卡顿。因此，V8 将标记的过程拆分为了一个一个的小任务（增量标记算法），与其他的 JavaScript 任务穿插执行

</br>
</br>
