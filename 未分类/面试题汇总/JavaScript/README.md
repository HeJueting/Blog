# JavaScript 面试题汇总

</br>

### 1、JavaScript 调用栈

1. 函数之间互相调用

2. JavaScript 使用栈结构来模拟函数调用

3. 每调用一个函数就会创建一个函数执行上下文，并把该执行上下文推入栈顶；函数执行完成之后，就会销毁改执行上下文

</br>
</br>

### 2、变量提升

运行 JS 代码时，会经历两个阶段：

1.  编译阶段：创建执行上下文，并把声明的变量和函数，保存在变量环境/词法环境中

    -   创建、初始化 var 定义的变量（保存在变量环境）
    -   创建、初始化、赋值定义的函数（保存在变量环境）
    -   创建 let/const 定义的变量（保存在词法环境）

2.  代码执行阶段：JavaScript 引擎会从变量环境/词法环境中去查找自定义的变量和函数

</br>
</br>

### 3、块级作用域和暂时性死区

1. 以花括号为准，一对花括号就能产生块级作用域，因此 if/for 等语句也能产生作用域

2. 主要将 let/const 定义的变量保存在词法环境中

3. var/let/const 定义的变量都会变量提升，只是 var 会在变量环境中创建并初始化该变量，而 let/const 只会在词法环境中创建该变量

4. 在 let/const 定义之前访问变量就会出现暂时性死区的错误

</br>
</br>

### 4、词法作用域与作用域链

1. 常见的有作用域：全局作用域、函数作用域

2. 词法作用域是在代码编写的时候就已经确定的，它由代码中函数声明的位置来决定

3. 函数运行时，会创建一个执行上下文，同时还会创建一个 outer 指针，该指针指向了另一个执行上下文（outer 的指向规则由词法作用域来决定），访问变量时，就会顺着 outer 指针不断查找该变量，这样就会形成一个链条，该链条就是作用域链。

</br>
</br>

### 5、闭包

1. 内层函数能访问到外层函数的变量，外层函数将该内层函数作为返回值 return 出去

2. 在全局环境下（或其他函数作用域下）执行这个运行这个外层函数的返回值，即使外层函数以及执行完了，但是依然能访问到外层函数中的变量，这就是闭包。

3. 闭包的原因：在 JavaScript 引擎解析代码时，如果发现闭包，就会在堆内存中新建一个对象用于保存该闭包所用到的变量

</br>
</br>

### 6、this 对象

1. this 对象是函数运行时所创建的一个对象，他永远指向最后调用它的对象

2. call 和 apply 方法可以改变 this 对象的指向

3. bind 方法会创建一个新的函数，并且永久改变该函数内部的 this 指向

</br>
</br>

### 7、栈空间和堆空间

1. 原始数据类型（String/Boolean/Number/null/undefined/BigInt/Symbol）和引用数据类型（Object/Fcuntion）

2. 原始数据类型是保存在栈空间中；引用数据类型保存在堆空间，其引用地址值保存在栈空间

</br>
</br>

### 8、垃圾回收

1. 栈空间的数据回收，执行上下文销毁后，就自动回收该执行上下文中变量环境中的所有数据

2. 堆空间的数据回收

    - 新生代区域（存活时间短且数据量小）和老生代区域（存活时间长/数据量大的数据）

    - 副垃圾回收器：回收新生代区域、采用 Scavenge 算法回收（活动对象区域与空闲对象区域翻转）

    - 主垃圾回收器：回收老生代区域、采用标记清除算法回收（遍历调用栈标记活动对象）、采用标记整理方法内存整理（将活动对象移动到某一端）

3. 使用增量标记方法优化全停顿的问题

</br>
</br>

### 9、事件循环

1. 浏览器将维护了**普通任务队列**和**延迟任务队列**

2. 每执行一个任务时，浏览器就会根据将该任务的类型，将其推入到相应任务队列中（setTimeout 属于延迟任务队列）

3. 每执行完一个普通任务，就会去延迟任务队列中判断是否有满足需求的延时任务需要执行

4. 这两种任务队列中又将任务分为了**宏任务**和**微任务**

5. 宏任务

    - 渲染事件（如解析 DOM、计算布局、绘制）
    - 用户交互事件（如鼠标点击、滚动页面、放大缩小等）
    - JavaScript 脚本执行事件
    - 网络请求完成、文件读写完成事件
    - setTimeout

6. 微任务

    - promise
    - MutationObserver 监听事件

7. 每个宏任务中都关联着一个微任务队列，当前宏任务执行完之后，就立即执行关联的微任务队列。在这个过程中，如果产生了新的微任务，继续执行微任务；如果产生新的宏任务，又将其添加到对应的任务队列中

</br>
</br>

### 10、原型链以及 new 关键字的作用

1. prototype 和 _proto_ 属性构成，_proto_ 属性不断指向上级的 prototype

2. new 关键字的作用
    1. 创建一个新的空对象
    2. 将这个对象的 _proto_ 属性指向构造函数的 prototype 属性
    3. 将构造函数 this 对象临时赋值给新对象
    4. 执行构造函数中的代码
    5. 如果这个函数有返回值，则返回；否则，就会默认返回新对象

</br>
</br>

### 11、对象的属性和遍历对象的方法

1. 对象的属性：可枚举性（Object.defineProperty）、所有权、Symbol 键

2. for...in、Object.keys、Reflect.ownKeys

</br>
</br>

### 12、浏览器缓存

1. cookie：存储在本地磁盘（存储数据量小）
    - session（注意区分 session 机制）：基于 cookie 将 sessionId 存储在本地，然后通过 sessionId 去服务端映射用户信息
