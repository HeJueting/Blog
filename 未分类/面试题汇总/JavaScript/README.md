# JavaScript 面试题汇总

</br>

### 1、JavaScript 调用栈

1. 函数之间互相调用

2. JavaScript 使用栈结构来模拟函数调用

3. 每调用一个函数就会创建一个函数执行上下文，并把该执行上下文推入栈顶；函数执行完成之后，就会

</br>
</br>

### 2、变量提升

运行 JS 代码时，会经历两个阶段：

1.  编译阶段：创建执行上下文，并把声明的变量和函数，保存在变量环境/词法环境中

    -   创建、初始化 var 定义的变量（保存在变量环境）
    -   创建、初始化、赋值定义的函数（保存在变量环境）
    -   创建 let/const 定义的变量（保存在词法环境）

2.  代码执行阶段：JavaScript 引擎会从变量环境/词法环境中去查找自定义的变量和函数

</br>
</br>

### 3、块级作用域和暂时性死区

1. 以花括号为准，一对花括号就能产生块级作用域，因此 if/for 等语句也能产生作用域

2. 主要将 let/const 定义的变量保存在词法环境中

3. var/let/const 定义的变量都会变量提升，只是 var 会在变量环境中创建并初始化该变量，而 let/const 只会在词法环境中创建该变量

4. 在 let/const 定义之前访问变量就会出现暂时性死区的错误

</br>
</br>

### 4、词法作用域与作用域链

1. 常见的有作用域：全局作用域、函数作用域

2. 词法作用域是在代码编写的时候就已经确定的，它由代码中函数声明的位置来决定

3. 函数运行时，会创建一个执行上下文，同时还会创建一个 outer 指针，该指针指向了另一个执行上下文（outer 的指向规则由词法作用域来决定），访问变量时，就会顺着 outer 指针不断查找该变量，这样就会形成一个链条，该链条就是作用域链。

</br>
</br>

### 5、this 对象

1. this 对象是函数运行时所创建的一个对象，他永远指向最后调用它的对象

2. call 和 apply 方法可以改变 this 对象的指向

3. bind 方法会创建一个新的函数，并且永久改变该函数内部的 this 指向

</br>
</br>

### 6、栈空间和堆空间

1. 原始数据类型（String/Boolean/Number/null/undefined/BigInt/Symbol）和引用数据类型（Object/Fcuntion）

2. 原始数据类型是保存在栈空间中；引用数据类型保存在堆空间，其引用地址值保存在栈空间

</br>
</br>

### 7、垃圾回收

1. 调用栈（栈空间）的数据回收，通过 ESP 指针移动来销毁该函数所创建的执行上下文

2. 堆空间的数据回收

    - 新生代区域（存活时间短且数据量小）和老生代区域（存活时间长/数据量大的数据）

    - 副垃圾回收器：回收老生代区域、采用 Scavenge 算法回收（活动对象区域与空闲对象区域翻转）

    - 主垃圾回收器：回收新生代区域、采用标记清除算法回收（遍历调用栈标记活动对象）、采用标记整理方法内存整理（将活动对象移动到某一端）

3. 使用增量标记方法优化全停顿的问题

</br>
</br>

### 8、事件循环

1. 浏览器将维护了**普通任务队列**和**延迟任务队列**

2. 每执行一个任务时，浏览器就会根据将该任务的类型，将其推入到相应任务队列中（setTimeout 属于延迟任务队列）

3. 每执行完一个普通任务，就会去延迟任务队列中判断是否有满足需求的延时任务需要执行

4. 任务队列中又将任务分为了**宏任务**和**微任务**

5. 宏任务

    - 渲染事件（如解析 DOM、计算布局、绘制）
    - 用户交互事件（如鼠标点击、滚动页面、放大缩小等）
    - JavaScript 脚本执行事件
    - 网络请求完成、文件读写完成事件
    - setTimeout

6. 微任务

    - promise
    - MutationObserver 监听事件

7. 每个宏任务都关联了一个微任务队列，当前宏任务执行完之后，就立即执行关联的微任务队列。在这个过程中，如果产生了新的任务，又会继续这个过程。

</br>
</br>
